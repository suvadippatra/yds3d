<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Double Slit Simulator (Fixed)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050810; font-family: sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; display: block; }
        #gui-container { position: absolute; top: 10px; right: 10px; z-index: 100; }
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #64ffda; font-size: 24px; pointer-events: none; transition: opacity 0.5s;
        }
        .instruction {
            position: absolute; bottom: 20px; left: 20px; color: #8892b0;
            background: rgba(0,0,0,0.5); padding: 10px; border-radius: 8px;
            pointer-events: none; user-select: none;
        }
    </style>
    
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>
</head>
<body>

    <div id="loading">Loading Simulator...</div>
    <div id="gui-container"></div>
    <div id="canvas-container"></div>
    <div class="instruction">
        <b>Controls:</b><br>
        Left Click: Rotate<br>
        Right Click: Pan<br>
        Scroll: Zoom
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

        // --- SCENE SETUP ---
        const container = document.getElementById('canvas-container');
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x050810);
        container.appendChild(renderer.domElement);

        const scene = new THREE.Scene();
        
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(2, 1.5, 3.5);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.target.set(0, 0, 0.5);

        // --- SIMULATION PARAMETERS ---
        const params = {
            wavelength: 0.08,    
            screenDistance: 1.5, 
            slitSeparation: 0.3, 
            slitWidth: 0.08,     
            intensity: 15.0,
            samples: 20,
            showGraph: true
        };

        // --- 1. THE SCREEN (SHADER) ---
        const vertexShader = `
            varying vec2 vUv;
            varying vec3 vPos;
            void main() {
                vUv = uv;
                vPos = position;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        const fragmentShader = `
            precision highp float;
            varying vec2 vUv;
            varying vec3 vPos;
            
            uniform float u_wavelength;
            uniform float u_screenZ;
            uniform float u_slitSep;
            uniform float u_slitWidth;
            uniform float u_intensity;
            uniform int u_samples;

            const float PI = 3.14159265359;

            vec2 cAdd(vec2 a, vec2 b) { return a + b; }
            vec2 cExp(float phase) { return vec2(cos(phase), sin(phase)); }

            vec2 pointSource(vec2 targetPos, vec2 sourcePos, float k) {
                float dx = targetPos.x - sourcePos.x;
                float dy = targetPos.y - sourcePos.y; 
                float dz = u_screenZ; // Vertical distance
                float r = sqrt(dx*dx + dy*dy + dz*dz);
                float phase = k * r;
                return (1.0 / r) * cExp(phase);
            }

            void main() {
                // Map UV to physical size (3.0 wide, 1.5 high)
                vec2 p = vec2(vPos.x, vPos.y); 

                float k = 2.0 * PI / u_wavelength;
                vec2 field = vec2(0.0);

                float halfSep = u_slitSep / 2.0;

                // Integration Loop
                for(int i = 0; i < 40; i++) {
                    if(i >= u_samples) break;
                    
                    float t = (float(i) + 0.5) / float(u_samples) - 0.5;
                    float xOffset = t * u_slitWidth;

                    // Left Slit Source
                    field = cAdd(field, pointSource(p, vec2(-halfSep + xOffset, 0.0), k));
                    // Right Slit Source
                    field = cAdd(field, pointSource(p, vec2(halfSep + xOffset, 0.0), k));
                }

                float I = dot(field, field); 
                I *= u_intensity * 0.01; 

                // Green Phosphor Color
                vec3 col = vec3(0.1, 0.9, 0.7) * I;
                // Core brightness (white center)
                col += vec3(1.0) * smoothstep(1.0, 3.0, I);
                
                // Vignette
                float vig = 1.0 - length(vUv - 0.5) * 1.5;
                col *= clamp(vig, 0.0, 1.0);

                gl_FragColor = vec4(col, 1.0);
            }
        `;

        const uniforms = {
            u_wavelength: { value: params.wavelength },
            u_screenZ: { value: params.screenDistance },
            u_slitSep: { value: params.slitSeparation },
            u_slitWidth: { value: params.slitWidth },
            u_intensity: { value: params.intensity },
            u_samples: { value: params.samples }
        };

        const screenGeo = new THREE.PlaneGeometry(3.0, 1.5);
        const screenMat = new THREE.ShaderMaterial({
            vertexShader, fragmentShader, uniforms, side: THREE.DoubleSide
        });
        const screenMesh = new THREE.Mesh(screenGeo, screenMat);
        scene.add(screenMesh);

        // --- 2. INTENSITY GRAPH (LINE) ---
        const MAX_POINTS = 300;
        const lineGeo = new THREE.BufferGeometry();
        const linePos = new Float32Array(MAX_POINTS * 3);
        lineGeo.setAttribute('position', new THREE.BufferAttribute(linePos, 3));
        const graphLine = new THREE.Line(lineGeo, new THREE.LineBasicMaterial({ color: 0xffff00 }));
        scene.add(graphLine);

        function updateGraph() {
            if(!params.showGraph) {
                graphLine.visible = false; return;
            }
            graphLine.visible = true;
            
            const k = 2.0 * Math.PI / params.wavelength;
            const z = params.screenDistance;
            const positions = graphLine.geometry.attributes.position.array;

            for(let i=0; i<MAX_POINTS; i++) {
                // Map 0..299 to x coordinates -1.5..1.5
                const x = (i / (MAX_POINTS-1)) * 3.0 - 1.5;
                
                let re = 0, im = 0;
                for(let s=0; s<params.samples; s++) {
                    const t = (s + 0.5) / params.samples - 0.5;
                    const xOff = t * params.slitWidth;
                    
                    const sources = [-params.slitSeparation/2 + xOff, params.slitSeparation/2 + xOff];
                    for(let srcX of sources) {
                        const dist = Math.sqrt((x - srcX)**2 + z*z);
                        const phase = k * dist;
                        const amp = 1.0 / dist;
                        re += amp * Math.cos(phase);
                        im += amp * Math.sin(phase);
                    }
                }
                const intensity = (re*re + im*im) * params.intensity * 0.01;
                
                positions[i*3] = x;
                positions[i*3+1] = intensity * 0.5; // Height scale
                positions[i*3+2] = 0.05; // Z-offset
            }
            graphLine.geometry.attributes.position.needsUpdate = true;
            graphLine.position.z = params.screenDistance;
        }

        // --- 3. SLIT GEOMETRY (SHUTTERS) ---
        const barrierMat = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.5, side: THREE.DoubleSide });
        const leftB = new THREE.Mesh(new THREE.PlaneGeometry(1,1), barrierMat);
        const rightB = new THREE.Mesh(new THREE.PlaneGeometry(1,1), barrierMat);
        const midB = new THREE.Mesh(new THREE.PlaneGeometry(1,1), barrierMat);
        const slitGroup = new THREE.Group();
        slitGroup.add(leftB, rightB, midB);
        scene.add(slitGroup);

        // --- 4. LIGHTS & HELPERS ---
        scene.add(new THREE.AmbientLight(0xffffff, 0.5));
        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(5, 5, 5);
        scene.add(dirLight);
        
        const grid = new THREE.GridHelper(20, 20, 0x333333, 0x111111);
        grid.position.y = -0.75;
        scene.add(grid);

        // --- UPDATER ---
        function update() {
            // Update Uniforms
            uniforms.u_wavelength.value = params.wavelength;
            uniforms.u_screenZ.value = params.screenDistance;
            uniforms.u_slitSep.value = params.slitSeparation;
            uniforms.u_slitWidth.value = params.slitWidth;
            uniforms.u_intensity.value = params.intensity;
            uniforms.u_samples.value = params.samples;

            // Update Screen Position
            screenMesh.position.z = params.screenDistance;

            // Update Slit Shutters
            const sep = params.slitSeparation;
            const w = params.slitWidth;
            
            // Middle Blocker
            const midWidth = Math.max(0, sep - w);
            midB.scale.set(midWidth, 2, 1);
            midB.visible = midWidth > 0.001;

            // Outer Blockers
            leftB.scale.set(2, 2, 1);
            leftB.position.set( (-sep/2 - w/2) - 1.0, 0, 0 );
            
            rightB.scale.set(2, 2, 1);
            rightB.position.set( (sep/2 + w/2) + 1.0, 0, 0 );

            updateGraph();
        }

        // --- GUI ---
        const gui = new GUI({ container: document.getElementById('gui-container') });
        gui.add(params, 'wavelength', 0.01, 0.2).name('Wavelength').onChange(update);
        gui.add(params, 'screenDistance', 0.5, 4.0).name('Screen Distance').onChange(update);
        gui.add(params, 'slitSeparation', 0.05, 1.0).name('Slit Separation').onChange(update);
        gui.add(params, 'slitWidth', 0.01, 0.3).name('Slit Width').onChange(update);
        gui.add(params, 'intensity', 1, 50).name('Intensity').onChange(update);
        gui.add(params, 'showGraph').name('Show Graph').onChange(update);

        // --- INIT & ANIMATE ---
        document.getElementById('loading').style.opacity = 0;
        update();

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        // Handle Window Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>